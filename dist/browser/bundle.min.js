(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PocketSafe=f()}})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.BasicEventEmitter=void 0;const _subscriptions=Symbol("subscriptions");const _oneTimeEvents=Symbol("oneTimeEvents");function runCallback(callback,...arg){callback(...arg)}class BasicEventEmitter{[_subscriptions];[_oneTimeEvents];_ready=false;constructor(){this[_subscriptions]=[];this[_oneTimeEvents]=new Map;this.on("internal_ready",()=>{this._ready=true})}async ready(callback){if(this._ready){const response=await callback?.();return Promise.resolve(response)}return new Promise(resolve=>{this.once("internal_ready",async()=>{const response=await callback?.();resolve(response)})})}get prepared(){return this._ready}set prepared(value){this.emit("internal_ready")}clearEvents(){this[_subscriptions]=[];this[_oneTimeEvents].clear()}on(event,callback){if(this[_oneTimeEvents].has(event)){runCallback(callback,...this[_oneTimeEvents].get(event)??[])}else{this[_subscriptions].push({event:event,callback:callback,once:false})}const self=this;return{stop(){self.off(event,callback)},remove(){this.stop()}}}off(event,callback){this[_subscriptions]=this[_subscriptions].filter(s=>s.event!==event||callback&&s.callback!==callback);return this}once(event,callback){return new Promise(resolve=>{const ourCallback=(...arg)=>{resolve();callback?.(...arg)};if(this[_oneTimeEvents].has(event)){runCallback(ourCallback,...this[_oneTimeEvents].get(event)??[])}else{this[_subscriptions].push({event:event,callback:ourCallback,once:true})}})}offOnce(event,callback){this[_subscriptions]=this[_subscriptions].filter(s=>s.event!==event||callback&&s.callback!==callback||!s.once);return this}emit(event,...arg){if(this[_oneTimeEvents].has(event)){throw new Error(`Event "${String(event)}" was supposed to be emitted only once`)}for(let i=0;i<this[_subscriptions].length;i++){const s=this[_subscriptions][i];if(s.event!==event){continue}runCallback(s.callback,...arg);if(s.once){this[_subscriptions].splice(i,1);i--}}return this}emitOnce(event,...arg){if(this[_oneTimeEvents].has(event)){throw new Error(`Event "${String(event)}" was supposed to be emitted only once`)}this.emit(event,...arg);this[_oneTimeEvents].set(event,arg);this.offOnce(event);return this}pipe(event,eventEmitter){return this.on(event,(...arg)=>{eventEmitter.emit(event,...arg)})}pipeOnce(event,eventEmitter){return this.once(event,(...arg)=>{eventEmitter.emitOnce(event,...arg)})}}exports.BasicEventEmitter=BasicEventEmitter;exports.default=BasicEventEmitter},{}]},{},[1])(1)});